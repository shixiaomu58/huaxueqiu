/*
 * Overlay 的基层管理类。
 * 
 * @since 2015-07-14
 */


/*
 * 定制图层的基础类引用。
 * 
 * @since 2015-07-14
 * @author dongxiaochai@163.com
 */
define(['jquery', "util"], function($, Util){
	// 检测当前页面是否已加载了必要的样式文件，若未使用则主动加载。
	var bIsCssLoaded = false;
	if ($("link[href*=overlay\\.min\\.css]").size() == 0) {
		Util.getStyle(GConfig.LIB_ADDRESS + "overlay/overlay.min.css?bust=" + GConfig.TAG, function() {
			bIsCssLoaded = true;
		});
	} else {
		bIsCssLoaded = true;
	}


	var
	// 图层模板。
	TEMPLATE =
		'<div class="base-overlay {elementClass}">'
		+	'<div class="ks-contentbox">'
		+		'{content}'
		+	'</div>'
		+	'{closable}'
		+ '</div>'
	,
	CLOSE_BUTTON_TEMPLATE = 
		  '<a tabindex="0" href="javascript:void(\'关闭\')" role="button" class="ks-ext-close">'
		+	'<span class="ks-ext-close-x">关闭</span>'
		+ '</a>'
	,
	MASKER_CLASS = "ks-ext-mask",
	MASKER_TEMPLATE = '<div class="' + MASKER_CLASS + '"></div>',

	MIN_WIDTH = 280,	// .title 中可显示的最小宽度，由于指定最小宽度后文字图标无法居中，因为尺寸将给于 .content-wrapper。
	MAX_WIDTH = 700,	// .title 中可显示的最大宽度。

	/**
	 * 事件类型。
	 */
	EVENT_TYPE = {
		AFTER_RENDER_UI: "afterrenderui",
		SHOW: "show",
		HIDE: "hide"
	},

	// 默认配置。
	DEFAULT_CONFIG = {
		mask : true,
		closable: true,

		// 所有回调的事件名都是小写。
		onafterrenderui: null,
		onshow: null,
		onhide: null
	},


	/**
	 * base
	 * 
	 * @method
	 * @param {Object|undefined} oConfig
	 *		type {String} 显示类型。 ({FN.ERROR_TYPE}) [{FN.SUCCESS_TYPE}|{FN.ERROR_TYPE}]
	 *		content {String} 内容。
	 *		onafterrenderui {Function|undefined} 构造 UI 完成后。 
	 *			#param {KISSYOverlay} 图层对象。
	 *		onshow {Function|undefined} 显示
	 *			#param {KISSYOverlay} 图层对象。
	 *		onhide {Function|undefined} 隐藏
	 *			#param {KISSYOverlay} 图层对象。
	 * @return {Object}
	 */
	Fn = function (oConfig) {
		// 合并默认配置。
		oConfig = $.extend({}, DEFAULT_CONFIG, oConfig || {});
		oConfig.content = Util.substitute(TEMPLATE, {
			elementClass: oConfig.elCls || "",
			content: oConfig.content || "",
			closable: oConfig.closable ? CLOSE_BUTTON_TEMPLATE : ""
		});

		var oThis = this;
		oThis.config = oConfig;	// 保存当前配置项。
		oThis._element = null;

		// 检测样式是否加载成功。
		if (!bIsCssLoaded) {
			// 轮循检测。
			var nInterval = setInterval(function() {
				if (bIsCssLoaded) {
					// 清除。
					clearInterval(nInterval);
					clearTimeout(nTimeout);

					oThis._init(); // 执行初始化。
				}
			}, 100);

			// 超时清除。
			var nTimeout = setTimeout(function() {
				clearInterval(nInterval);

				// 抛出异常。
				throw("基础样式文件加载超时，Overlay-base 初始化失败");
			}, 5 * 1000);
		} else {
			oThis._init(); // 执行初始化。
		}
	}
	;


	Fn.prototype = {
		/**
		 * 初始化。
		 * 
		 * @method
		 * @return {Class}
		 */
		_init: function() {
			return this._renderUI();
		},


		/**
		 * 创建 UI 。
		 * 
		 * @method
		 * @return {Class}
		 */
		_renderUI: function() {
			var cSelf = this,
				oConfig = cSelf.config,
				jElement = null,
				jContentElement = null
			;

			cSelf._element =
			jElement = $(oConfig.content)
				.on(EVENT_TYPE.AFTER_RENDER_UI, oConfig.onafterrenderui)
				.on(EVENT_TYPE.SHOW, oConfig.onshow)
				.on(EVENT_TYPE.HIDE, oConfig.onhide)
				.appendTo("body")
			;
			jContentElement = jElement.find(".ks-contentbox");


			// 触发 afterrenderui 事件。
			jElement.trigger("afterrenderui", cSelf);
			
			
			/*
			 * 如果动态加载样式，则由于时间差会造成一定的计算错误，
			 * 这里先做一些必要的样式设置。
			 */
			jElement.css("position", "fixed");


			// 侦听关闭按钮事件。
			jElement.find(".ks-ext-close").on("click", function() {
				cSelf.hide();
			});


			// 检测是否需要设置遮罩。
			if (oConfig.mask && !$("." + MASKER_CLASS).length) {
				$(MASKER_TEMPLATE).prependTo("body");
			}


			// 检测最小宽度。
			var jTitle = jContentElement.find(".title"),
				nCotentWidth = jTitle.width() + jContentElement.find(".icon").width()
			;
			if (nCotentWidth < MIN_WIDTH) {
				jContentElement.find(".content-wrapper").css("width", MIN_WIDTH);
			} else if (nCotentWidth > MAX_WIDTH) {
				jTitle.css({
					// width: MAX_WIDTH,
					whiteSpace: "normal"	// 取消不换行样式。
				});
			}

			return cSelf.center();	// 立即居中显示。
		},


		/**
		 * 获取整个节点对象。
		 * 
		 * @method
		 * @return {jQuery}
		 */
		getElement: function() {
			return this._element;
		},


		/**
		 * 获取 ks-contentbox 节点对象。
		 * 
		 * @method
		 * @return {jQuery}
		 */
		getContentElement: function() {
			return this.getElement().find(".ks-contentbox");
		},


		/**
		 * 显示当前节点。
		 * 
		 * @method
		 * @return {Class}
		 */
		show: function() {
			var oThis = this,
				jElement = oThis.getElement()
			;

			if (oThis.config.mask) {
				$("." + MASKER_CLASS).show();
			}

			if (jElement.css("visibility") == "hidden") {	// 仅在隐藏的情况下才触发。
				jElement.css("visibility", "visible").trigger(EVENT_TYPE.SHOW, oThis);
			}

			return oThis;
		},


		/**
		 * 隐藏当前节点。
		 * 
		 * @method
		 * @return {Class}
		 */
		hide: function() {
			var oThis = this,
				jElement = oThis.getElement()
			;

			$("." + MASKER_CLASS).hide();

			if (jElement.css("visibility") != "hidden") {	// 仅在非隐藏属性下才触发。
				jElement.css("visibility", "hidden").trigger(EVENT_TYPE.HIDE, oThis);
			}

			return oThis;
		},


		/**
		 * 水平、垂直居中显示。
		 * 会间接的调用 show。
		 * 
		 * @method
		 * @return {Class}
		 */
		center: function() {
			var oThis = this,
				jElement = oThis.getElement(),
				oDocE = document.documentElement,
				nWinHeight = $(window).height(),
				nScrollTop = oDocE.scrollTop || document.body.scrollTop
			;

			var nHeadHeight = 0;//头部webview以外区域高度
			if(window.screen.availHeight){
				nHeadHeight = window.screen.availHeight - $(window).height()
			}

			jElement.css({
				marginLeft: "-" + (jElement.outerWidth() / 2) + "px",
				marginTop:  "-" + ((jElement.outerHeight()) / 2) + "px"
				// marginTop:  "-" + ((jElement.outerHeight() + nHeadHeight) / 2) + "px"
				// left: (oDocE.clientWidth - jElement.outerWidth()) / 2,
				// top: nScrollTop + (oDocE.clientHeight - jElement.outerHeight()) / 2
			});

			return oThis.show();
		},


		/**
		 * 销毁当前 DOM 结构。
		 * 
		 * @method
		 * @return {Class}
		 */
		destroy: function() {
			var oThis = this,
				jElement = oThis.getElement()
			;

			$("." + MASKER_CLASS).hide();
			jElement.remove();

			Overlay.instance = null;
			
			return oThis;
		}
	};


	// 静态成员设置。
	Fn.SUCCESS_TYPE = "success";
	Fn.ERROR_TYPE = "error";
	Fn.EVENT_TYPE = EVENT_TYPE;

	window.Overlay = Fn;

	return Fn;
});